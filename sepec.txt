üëâ une Specification g√©n√©rique, r√©utilisable pour toutes les entit√©s.

Objectif :
‚úÖ Ne plus cr√©er PersonneSpecifications, ProduitSpecifications, etc.
‚úÖ Avoir une seule classe g√©n√©rique capable de :

Filtrage par plage de dates

Recherche par sous-cha√Æne multi-champs

Tri dynamique

Pagination

Et applicable √† n‚Äôimporte quelle entit√© JPA

‚úÖ 1. Exigences techniques minimales
Outil	Version minimale
Java	17
Spring Boot	3.5.6
Spring Data JPA	Inclus
Hibernate	6.x
Maven	3.9+
‚úÖ 2. Probl√®me avec ton approche actuelle

Actuellement tu as :

PersonneSpecifications


‚û° Probl√®me :

Non r√©utilisable pour d‚Äôautres entit√©s (Produit, Client, Commande)

Duplication de code

Maintenance lourde

Violation du principe DRY

‚úÖ 3. Solution professionnelle : Specification G√©n√©rique

On va cr√©er :

‚úÖ Une classe SearchCriteria
‚úÖ Une classe GenericSpecification<T>
‚úÖ Un SpecificationBuilder<T>
‚úÖ Un service g√©n√©rique r√©utilisable

‚úÖ 4. Classe g√©n√©rique SearchCriteria
public class SearchCriteria {

    private String field;
    private String operation; // "like", "=", "between"
    private Object value;
    private Object value2; // utilis√© pour BETWEEN

    public SearchCriteria(String field, String operation, Object value) {
        this.field = field;
        this.operation = operation;
        this.value = value;
    }

    public SearchCriteria(String field, Object value, Object value2) {
        this.field = field;
        this.operation = "between";
        this.value = value;
        this.value2 = value2;
    }

    // getters
}

‚úÖ 5. Specification G√©n√©rique Universelle
public class GenericSpecification<T> implements Specification<T> {

    private final SearchCriteria criteria;

    public GenericSpecification(SearchCriteria criteria) {
        this.criteria = criteria;
    }

    @Override
    public Predicate toPredicate(
            Root<T> root,
            CriteriaQuery<?> query,
            CriteriaBuilder cb) {

        switch (criteria.getOperation()) {

            case "like":
                return cb.like(
                        cb.lower(root.get(criteria.getField())),
                        "%" + criteria.getValue().toString().toLowerCase() + "%"
                );

            case "=":
                return cb.equal(root.get(criteria.getField()), criteria.getValue());

            case "between":
                return cb.between(
                        root.get(criteria.getField()),
                        (Comparable) criteria.getValue(),
                        (Comparable) criteria.getValue2()
                );

            default:
                return null;
        }
    }
}


‚úÖ Fonctionne pour toutes les entit√©s JPA.

‚úÖ 6. Builder g√©n√©rique pour combiner plusieurs filtres
public class SpecificationBuilder<T> {

    private final List<SearchCriteria> params = new ArrayList<>();

    public SpecificationBuilder<T> with(String field, String operation, Object value) {
        params.add(new SearchCriteria(field, operation, value));
        return this;
    }

    public SpecificationBuilder<T> between(String field, Object from, Object to) {
        params.add(new SearchCriteria(field, from, to));
        return this;
    }

    public Specification<T> build() {

        if (params.isEmpty()) {
            return null;
        }

        Specification<T> result = new GenericSpecification<>(params.get(0));

        for (int i = 1; i < params.size(); i++) {
            result = Specification.where(result)
                    .and(new GenericSpecification<>(params.get(i)));
        }

        return result;
    }
}

‚úÖ 7. Utilisation concr√®te dans ton service PersonneService
@Service
public class PersonneService {

    private final PersonneRepository repository;

    public PersonneService(PersonneRepository repository) {
        this.repository = repository;
    }

    public Page<PersonneDto> rechercher(
            int page,
            int size,
            String sortField,
            String sortDir,
            LocalDate dateDebut,
            LocalDate dateFin,
            String search
    ) {

        Sort sort = sortDir.equalsIgnoreCase("desc")
                ? Sort.by(sortField).descending()
                : Sort.by(sortField).ascending();

        Pageable pageable = PageRequest.of(page, size, sort);

        SpecificationBuilder<Personne> builder = new SpecificationBuilder<>();

        if (dateDebut != null && dateFin != null) {
            builder.between("dateNaissance", dateDebut, dateFin);
        }

        if (search != null && !search.isBlank()) {
            builder.with("nom", "like", search);
            builder.with("prenom", "like", search);
            builder.with("adresse", "like", search);
        }

        Specification<Personne> spec = builder.build();

        return repository.findAll(spec, pageable)
                .map(this::toDto);
    }

    private PersonneDto toDto(Personne p) {
        PersonneDto dto = new PersonneDto();
        dto.setId(p.getId());
        dto.setNom(p.getNom());
        dto.setPrenom(p.getPrenom());
        dto.setAdresse(p.getAdresse());
        dto.setDateNaissance(p.getDateNaissance());
        dto.setEmail(p.getEmail());
        return dto;
    }
}

‚úÖ 8. R√©utilisation imm√©diate sur une autre entit√© (ex: Produit)

Tu n‚Äô√©cris AUCUNE nouvelle Specification :

SpecificationBuilder<Produit> builder = new SpecificationBuilder<>();

builder.with("libelle", "like", search);
builder.between("dateCreation", dateDebut, dateFin);

Specification<Produit> spec = builder.build();


‚úÖ Le m√™me moteur fonctionne pour :

Personne

Produit

Client

Commande

Facture

‚úÖ 9. Avantages Architecture
Crit√®re	Gain
R√©utilisation	‚úÖ 100%
Maintenance	‚úÖ Facile
Extensibilit√©	‚úÖ Ajout simple d‚Äôop√©rations
Performance	‚úÖ Hibernate optimize
Clean Code	‚úÖ Respect SOLID
Testabilit√©	‚úÖ Forte
‚úÖ 10. Bonus : s√©curiser les champs triables

Tr√®s important en prod :

Set<String> allowedFields = Set.of("id", "nom", "prenom", "dateNaissance");

if (!allowedFields.contains(sortField)) {
    sortField = "id";
}

‚úÖ 11. Sources officielles

Spring Data JPA Specifications
https://docs.spring.io/spring-data/jpa/reference/specifications.html

JPA Criteria API
https://jakarta.ee/specifications/persistence/3.1/

Hibernate 6 Criteria
https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#criteria

‚úÖ 12. En r√©sum√©

‚úÖ Tu supprimes toutes tes classes XXXSpecifications
‚úÖ Tu utilises un moteur g√©n√©rique unique
‚úÖ Tu appliques le m√™me syst√®me √† toutes tes APIs pagin√©es
‚úÖ Tu es conforme aux standards Spring pro
